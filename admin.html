<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>MovieDrift Admin</title>
<link rel="icon" href="img/logo.png" type="image/png">
<style>
:root { --bg:#000; --card-bg:#0a0a0a; --accent:#00ff66; --text:#eee; --muted:#777; }
body { background:var(--bg); color:var(--text); font-family:Arial,sans-serif; margin:0; }
header { background:#111; color:var(--accent); padding:15px 20px; font-size:24px; font-weight:bold; }
main { padding:20px; display:grid; grid-template-columns:300px 1fr; gap:20px; flex-wrap:wrap; }
form { background:var(--card-bg); padding:15px; border-radius:8px; display:flex; flex-direction:column; gap:10px; }
input, textarea, select, button { padding:8px; border:1px solid var(--accent); border-radius:5px; background:#111; color:var(--text); }
button { background:var(--accent); color:#000; font-weight:bold; cursor:pointer; }
button:hover { opacity:0.85; }
table { width:100%; border-collapse:collapse; background:var(--card-bg); border-radius:8px; overflow:hidden; }
th, td { border-bottom:1px solid #222; padding:8px; text-align:left; }
th { color:var(--accent); background:#111; }
tr:hover { background:#181818; }
.actions button { margin-right:6px; padding:4px 8px; border:none; border-radius:4px; cursor:pointer; font-size:0.8rem; }
.actions .edit { background:#00cc88; color:#000; }
.actions .delete { background:#e63946; color:#fff; }
.search-bar { margin-bottom:10px; width:100%; }
@media(max-width:900px){ main { grid-template-columns:1fr; } }
</style>
</head>
<body>
<header>ðŸŽ¬ MovieDrift Admin Dashboard</header>

<main>
  <!-- ADD / EDIT MOVIE FORM -->
  <form id="movieForm">
    <h3>Add / Edit Movie</h3>
    <input type="hidden" id="movieId">
    <input id="title" placeholder="Title" required>
    <input id="year" placeholder="Year" required>
    <input id="type" placeholder="Type (Movie, Series, Animation)" required>
    <input id="genres" placeholder="Genres (comma separated)" required>
    <input id="poster" placeholder="Poster URL" required>
    <input id="trailer" placeholder="Trailer URL">
    <input id="fileUrl" placeholder="Movie / Stream URL">
    <textarea id="description" placeholder="Description"></textarea>
    <input id="rating" type="number" placeholder="Rating (0-10)" min="0" max="10" step="0.1">
    <button type="submit">Save Movie</button>
  </form>

  <!-- MOVIES TABLE -->
  <div>
    <h3>ðŸŽž All Movies</h3>
    <input id="searchInput" class="search-bar" placeholder="ðŸ” Search movies by title...">
    <div style="margin-bottom:10px;">
      <button id="deleteSelectedBtn" onclick="deleteSelectedMovies()" disabled>ðŸ—‘ Delete Selected</button>
    </div>
    <table>
      <thead>
        <tr>
          <th><input type="checkbox" id="selectAll" onchange="toggleSelectAll(this)"></th>
          <th>Title</th>
          <th>Year</th>
          <th>Type</th>
          <th>Genres</th>
          <th>Rating</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody id="movieTable"></tbody>
    </table>
  </div>
</main>

<script type="module"> 
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import { 
  getFirestore, collection, addDoc, getDocs, updateDoc, deleteDoc, doc, onSnapshot, query, where, orderBy
} from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

// -------------------- Firebase Config --------------------
const firebaseConfig = {
  apiKey: "AIzaSyD2gkLs17Oa_dxIGu1FpOaDKAvGZwj_EFA",
  authDomain: "gamers-65b44.firebaseapp.com",
  projectId: "gamers-65b44",
  storageBucket: "gamers-65b44.firebasestorage.app",
  messagingSenderId: "97331968745",
  appId: "1:97331968745:web:a93ff0bd2c383800dcce78",
  measurementId: "G-JPPCZ3M4G2"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const moviesRef = collection(db, "movies");

const movieForm = document.getElementById("movieForm");
const movieTable = document.getElementById("movieTable");
const searchInput = document.getElementById("searchInput");
const deleteSelectedBtn = document.getElementById("deleteSelectedBtn");
const TMDB_API_KEY = "4d2474df29f79bf9c784634d44137413";

let allMovies = [];
let selectedMovies = new Set(); // Track multi-selection

// -------------------- FETCH FROM TMDb (Full Date Check + Auto Genres + Update Support + Weekly Auto Run + Background Timer) --------------------
async function fetchAllTMDbContent() {
  const PAGES = 7;
  const endpoints = [
    { type: "Movie", label: "Now Playing", baseUrl: "https://api.themoviedb.org/3/movie/now_playing" },
    { type: "Movie", label: "Popular", baseUrl: "https://api.themoviedb.org/3/movie/popular" },
    { type: "Series", label: "Popular", baseUrl: "https://api.themoviedb.org/3/tv/popular" },
    { type: "Anime", label: "Popular", baseUrl: "https://api.themoviedb.org/3/discover/tv?with_original_language=ja&sort_by=popularity.desc" },
    { type: "Animation", label: "Popular", baseUrl: "https://api.themoviedb.org/3/discover/movie?with_genres=16&sort_by=popularity.desc" }
  ];

  try {
    const now = new Date();

    // ðŸ§  Fetch genre lists for movies and TV
    const [movieGenresRes, tvGenresRes] = await Promise.all([
      fetch(`https://api.themoviedb.org/3/genre/movie/list?api_key=${TMDB_API_KEY}&language=en-US`),
      fetch(`https://api.themoviedb.org/3/genre/tv/list?api_key=${TMDB_API_KEY}&language=en-US`)
    ]);

    const movieGenres = (await movieGenresRes.json()).genres || [];
    const tvGenres = (await tvGenresRes.json()).genres || [];

    // Combine into one genre map
    const genreMap = {};
    [...movieGenres, ...tvGenres].forEach(g => (genreMap[g.id] = g.name));

    // ðŸŽž Loop through all endpoints
    for (const endpoint of endpoints) {
      console.log(`ðŸ”„ Fetching ${endpoint.label} ${endpoint.type}s...`);

      for (let page = 1; page <= PAGES; page++) {
        const url = endpoint.baseUrl.includes("?")
          ? `${endpoint.baseUrl}&api_key=${TMDB_API_KEY}&language=en-US&page=${page}`
          : `${endpoint.baseUrl}?api_key=${TMDB_API_KEY}&language=en-US&page=${page}`;

        const res = await fetch(url);
        const data = await res.json();
        const results = Array.isArray(data.results) ? data.results : [data];

        for (const item of results) {
          if (!item || (!item.title && !item.name)) continue;

          const title = item.title || item.name;
          const releaseDateStr = item.release_date || item.first_air_date;
          if (!releaseDateStr) continue; // skip missing release date

          const releaseDate = new Date(releaseDateStr);
          if (isNaN(releaseDate)) continue; // skip invalid dates
          if (releaseDate > now) continue; // â›” skip unreleased (future) titles

          const year = releaseDate.getFullYear();
          const month = releaseDate.getMonth() + 1;
          const day = releaseDate.getDate();

          // skip items that have no poster
          if (!item.poster_path) continue;

          const poster = `https://image.tmdb.org/t/p/w500${item.poster_path}`;
          const rating = item.vote_average || null;
          const description = item.overview || "";
          const genreNames = (item.genre_ids || []).map(id => genreMap[id]).filter(Boolean);

          // ðŸ” Check if the movie already exists
          const q = query(moviesRef, where("title", "==", title));
          const existingSnap = await getDocs(q);

          if (!existingSnap.empty) {
            // âœ… Update existing entry
            for (const docSnap of existingSnap.docs) {
              await updateDoc(doc(db, "movies", docSnap.id), {
                year,
                releaseDate: releaseDateStr,
                month,
                day,
                type: endpoint.type,
                description,
                rating,
                poster,
                genres: genreNames,
                category: endpoint.label,
                updatedAt: Date.now(),
              });
              console.log(`ðŸ” Updated: ${title}`);
            }
          } else {
            // ðŸ†• Add new entry
            await addDoc(moviesRef, {
              title,
              year,
              month,
              day,
              releaseDate: releaseDateStr,
              type: endpoint.type,
              genres: genreNames,
              poster,
              trailer: "",
              fileUrl: "",
              description,
              rating,
              source: "tmdb",
              category: endpoint.label,
              createdAt: Date.now(),
            });
            console.log(`âœ… Added: ${title}`);
          }
        }
      }

      console.log(`âœ… Completed ${endpoint.label} ${endpoint.type}s!`);
    }

    alert("ðŸŽ‰ All released movies, series, anime, and animations fetched (checked by full date)!");
  } catch (e) {
    console.error("TMDb fetch error:", e);
    alert("âš ï¸ TMDb fetch failed. Check console for details.");
  }
}

// -------------------- AUTO RUN WEEKLY (WITH BACKGROUND CHECK) --------------------
async function autoRunWeeklyTMDbFetch() {
  const lastRun = localStorage.getItem("tmdb_last_run");
  const now = Date.now();
  const oneWeek = 7 * 24 * 60 * 60 * 1000; // 7 days

  if (!lastRun || now - lastRun > oneWeek) {
    console.log("â° It's been a week (or never). Running TMDb auto-fetch...");
    await fetchAllTMDbContent();
    localStorage.setItem("tmdb_last_run", now);
  } else {
    const daysLeft = Math.ceil((oneWeek - (now - lastRun)) / (24 * 60 * 60 * 1000));
    console.log(`âœ… TMDb auto-fetch not needed yet. Next run in ~${daysLeft} day(s).`);
  }
}

// ðŸ”„ Run once on load
autoRunWeeklyTMDbFetch();

// â± Background check every 12 hours (in case the site stays open)
setInterval(() => {
  console.log("ðŸ•’ Background TMDb check running...");
  autoRunWeeklyTMDbFetch();
}, 12 * 60 * 60 * 1000); // 12 hours

// -------------------- RENDER MOVIES --------------------
function renderMovies(list) {
  movieTable.innerHTML = "";
  list.forEach(m => {
    const checked = selectedMovies.has(m.id) ? "checked" : "";
    const ratingDisplay = m.rating ? `${m.rating} (${(m.rating*10).toFixed(0)}%)` : "-";
    const row = document.createElement("tr");
    row.innerHTML = `
      <td><input type="checkbox" ${checked} onchange="toggleMovieSelection('${m.id}')"></td>
      <td>${m.title}</td>
      <td>${m.year}</td>
      <td>${m.type}</td>
      <td>${m.genres ? m.genres.join(", ") : ""}</td>
      <td>${ratingDisplay}</td>
      <td class="actions">
        <button class="edit" onclick='editMovie("${m.id}")'>Edit</button>
        <button class="delete" onclick='deleteMovie("${m.id}")'>Delete</button>
      </td>`;
    movieTable.appendChild(row);
  });
  updateDeleteButtonState();
}

// -------------------- TOGGLE SELECTION --------------------
window.toggleMovieSelection = id => {
  if (selectedMovies.has(id)) selectedMovies.delete(id);
  else selectedMovies.add(id);
  updateDeleteButtonState();
};

window.toggleSelectAll = checkbox => {
  if (checkbox.checked) allMovies.forEach(m => selectedMovies.add(m.id));
  else selectedMovies.clear();
  renderMovies(allMovies);
};

function updateDeleteButtonState() {
  deleteSelectedBtn.disabled = selectedMovies.size === 0;
  deleteSelectedBtn.textContent = selectedMovies.size
    ? `ðŸ—‘ Delete Selected (${selectedMovies.size})`
    : "ðŸ—‘ Delete Selected";
}

// -------------------- DELETE SELECTED --------------------
window.deleteSelectedMovies = async () => {
  if (selectedMovies.size === 0) return alert("No movies selected.");
  if (!confirm(`Delete ${selectedMovies.size} selected movie(s)?`)) return;
  for (const id of selectedMovies) {
    await deleteDoc(doc(db, "movies", id));
  }
  selectedMovies.clear();
  updateDeleteButtonState();
  alert("âœ… Selected movies deleted successfully!");
};

// -------------------- SINGLE DELETE --------------------
window.deleteMovie = async id => {
  if (confirm("Delete this movie?")) {
    await deleteDoc(doc(db, "movies", id));
    alert("ðŸ—‘ Movie deleted");
  }
};

// -------------------- LOAD MOVIES REALTIME --------------------
onSnapshot(query(moviesRef, orderBy("createdAt", "desc")), snapshot => {
  allMovies = [];
  snapshot.forEach(docSnap => allMovies.push({ id: docSnap.id, ...docSnap.data() }));
  renderMovies(allMovies);
});

// -------------------- SEARCH FILTER --------------------
searchInput.addEventListener("input", e => {
  const term = e.target.value.toLowerCase();
  const filtered = allMovies.filter(m => m.title.toLowerCase().includes(term));
  renderMovies(filtered);
});

// -------------------- ADD / UPDATE MOVIE --------------------
movieForm.addEventListener("submit", async e => {
  e.preventDefault();
  const movieData = {
    title: title.value.trim(),
    year: year.value.trim(),
    type: type.value.trim(),
    genres: genres.value.split(",").map(g => g.trim()),
    poster: poster.value.trim(),
    trailer: trailer.value.trim(),
    fileUrl: fileUrl.value.trim(),
    description: description.value.trim(),
    rating: parseFloat(rating.value) || null
  };
  const id = movieId.value;
  if (id) {
    await updateDoc(doc(db, "movies", id), movieData);
    alert("âœ… Movie updated!");
  } else {
    const q = query(moviesRef, where("title", "==", movieData.title));
    const existing = await getDocs(q);
    if (!existing.empty) return alert("âš ï¸ Movie already exists. Edit it instead of adding.");
    movieData.createdAt = Date.now();
    await addDoc(moviesRef, movieData);
    alert("âœ… Movie added!");
  }
  movieForm.reset();
  movieId.value = "";
});

// -------------------- EDIT MOVIE --------------------
window.editMovie = async id => {
  const docs = await getDocs(moviesRef);
  const movieDoc = docs.docs.find(d => d.id === id);
  if (!movieDoc) return alert("Movie not found!");
  const m = movieDoc.data();
  movieId.value = id;
  title.value = m.title;
  year.value = m.year;
  type.value = m.type;
  genres.value = m.genres ? m.genres.join(", ") : "";
  poster.value = m.poster;
  trailer.value = m.trailer || "";
  fileUrl.value = m.fileUrl || "";
  description.value = m.description || "";
  rating.value = m.rating || "";
  window.scrollTo({ top: 0, behavior: "smooth" });
};
</script>

</body>
</html>
